"""
Pleasance Cloud Reviewer

Quality review agent using Antigravity Claude Proxy.
Reviews content generated by T1 workers and creates flags for issues.

Uses the Antigravity proxy for rate-limit-aware API access with
automatic fallback to Gemini models when Claude is unavailable.

Usage:
  1. Ensure Antigravity proxy is running: antigravity-claude-proxy start
  2. Set AGENT_SECRET
  3. Run: python cloud_reviewer.py
"""

import os
import time
import json
import requests
from typing import List, Dict, Optional

# Configuration
API_URL = os.environ.get("PLEASANCE_API", "https://api.pleasance.app")
AGENT_SECRET = os.environ["AGENT_SECRET"]
AGENT_ID = os.environ.get("AGENT_ID", "cloud-reviewer")
BATCH_SIZE = int(os.environ.get("BATCH_SIZE", "5"))

# Antigravity Proxy Configuration
# The proxy runs on localhost:8080 and provides unified access to Claude/Gemini
PROXY_BASE_URL = os.environ.get("ANTHROPIC_BASE_URL", "http://localhost:8080")

# Model fallback chain (per Antigravity resilience mandate)
MODEL_CHAIN = [
    "claude-sonnet-4-5",       # Primary: Claude Sonnet
    "gemini-2.5-flash",        # Fallback 1: Fast Gemini
    "gemini-2.5-pro",          # Fallback 2: Pro Gemini
]

HEADERS = {
    "X-Agent-Key": AGENT_SECRET,
    "X-Agent-Id": AGENT_ID,
    "Content-Type": "application/json"
}

REVIEW_PROMPT = """You are a content quality reviewer for an educational encyclopedia about human sexuality and kink.

Review the following content for:
1. **Factual accuracy** - Is the information correct?
2. **Tone consistency** - Is it educational, non-judgmental, and informative?
3. **Safety** - Does it include appropriate safety warnings where needed?
4. **Completeness** - Is the section adequately developed?

Content to review:
KINK: {name}
CATEGORY: {category}
SECTION: {section_key}

CONTENT:
{content}

Respond in JSON format:
{{
  "approved": true/false,
  "issues": ["list of specific issues found"],
  "severity": "none|low|medium|high",
  "suggested_changes": "brief description of changes needed or null"
}}
"""


def check_proxy_health() -> bool:
    """Check if Antigravity proxy is running."""
    try:
        resp = requests.get(f"{PROXY_BASE_URL}/health", timeout=3)
        return resp.status_code == 200
    except:
        return False


def call_model_via_proxy(prompt: str, model: str) -> Optional[str]:
    """
    Call model through Antigravity proxy.
    Uses the Claude Messages API format which the proxy translates.
    """
    try:
        resp = requests.post(
            f"{PROXY_BASE_URL}/v1/messages",
            headers={"Content-Type": "application/json"},
            json={
                "model": model,
                "max_tokens": 1024,
                "messages": [{"role": "user", "content": prompt}]
            },
            timeout=60
        )
        
        if resp.status_code == 200:
            data = resp.json()
            # Handle Claude/Anthropic response format
            if "content" in data and len(data["content"]) > 0:
                return data["content"][0].get("text", "")
            # Handle Gemini response format (proxied)
            if "text" in data:
                return data["text"]
        else:
            print(f"    [WARN] Model {model} returned {resp.status_code}")
            
    except requests.Timeout:
        print(f"    [WARN] Model {model} timed out")
    except Exception as e:
        print(f"    [ERROR] Model {model}: {e}")
    
    return None


def review_with_fallback(kink: Dict, section_key: str, content: str) -> Dict:
    """
    Review content using model fallback chain.
    Implements "Never Fully Fail" mandate.
    """
    prompt = REVIEW_PROMPT.format(
        name=kink.get("name", "Unknown"),
        category=kink.get("category", "Unknown"),
        section_key=section_key,
        content=content
    )
    
    for model in MODEL_CHAIN:
        response = call_model_via_proxy(prompt, model)
        
        if response:
            # Parse JSON from response
            try:
                json_start = response.find('{')
                json_end = response.rfind('}') + 1
                if json_start != -1 and json_end > json_start:
                    result = json.loads(response[json_start:json_end])
                    result["_model_used"] = model
                    return result
            except json.JSONDecodeError:
                print(f"    [WARN] Failed to parse JSON from {model}")
                continue
        
        print(f"    [FALLBACK] Trying next model...")
    
    # All models failed - approve by default to avoid blocking
    print("    [ERROR] All models exhausted, auto-approving")
    return {"approved": True, "issues": [], "severity": "none", "_fallback": True}


def get_processed_items(limit: int = BATCH_SIZE) -> List[Dict]:
    """Fetch recently processed kinks for review."""
    try:
        resp = requests.get(
            f"{API_URL}/api/kinks",
            params={"processed": "true", "limit": limit, "sortBy": "updatedAt", "sortOrder": "DESC"},
            headers=HEADERS,
            timeout=30
        )
        resp.raise_for_status()
        return resp.json().get("kinks", [])
    except requests.RequestException as e:
        print(f"[ERROR] Failed to fetch items: {e}")
        return []


def get_kink_sections(kink_id: str) -> Dict:
    """Fetch full kink details including sections."""
    try:
        resp = requests.get(
            f"{API_URL}/api/kinks/{kink_id}",
            headers=HEADERS,
            timeout=30
        )
        resp.raise_for_status()
        return resp.json()
    except requests.RequestException as e:
        print(f"[ERROR] Failed to fetch kink {kink_id}: {e}")
        return {}


def create_flag(kink_id: str, section_key: str, issues: List[str], severity: str) -> bool:
    """Create review flag in API."""
    flag_type = "quality" if severity in ["low", "medium"] else "factual" if severity == "high" else "other"
    
    try:
        resp = requests.post(
            f"{API_URL}/api/bulk/flags",
            json={"flags": [{
                "kinkId": kink_id,
                "sectionKey": section_key,
                "flagType": flag_type,
                "note": f"[{severity.upper()}] " + "; ".join(issues)
            }]},
            headers=HEADERS,
            timeout=30
        )
        resp.raise_for_status()
        return True
    except requests.RequestException as e:
        print(f"[ERROR] Failed to create flag: {e}")
        return False


def review_kink(kink: Dict) -> int:
    """Review all sections of a kink. Returns count of flags created."""
    kink_id = kink["id"]
    kink_name = kink["name"]
    
    full_kink = get_kink_sections(kink_id)
    if not full_kink:
        return 0
    
    sections = full_kink.get("pageSections", [])
    flags_created = 0
    
    for section in sections:
        section_key = section.get("sectionKey")
        content = section.get("content") or section.get("contentFormatted")
        
        if not content or len(content) < 50:
            continue
        
        print(f"  → Reviewing {kink_name}/{section_key}")
        
        result = review_with_fallback(full_kink, section_key, content)
        
        model_used = result.get("_model_used", "unknown")
        
        if not result.get("approved", True):
            issues = result.get("issues", [])
            severity = result.get("severity", "low")
            
            print(f"    [FLAG] {severity} via {model_used}: {', '.join(issues[:2])}")
            create_flag(kink_id, section_key, issues, severity)
            flags_created += 1
        else:
            print(f"    [OK] via {model_used}")
    
    return flags_created


def main():
    """Main reviewer loop."""
    print(f"=== Pleasance Cloud Reviewer (Antigravity Proxy) ===")
    print(f"API: {API_URL}")
    print(f"Proxy: {PROXY_BASE_URL}")
    print(f"Agent: {AGENT_ID}")
    print(f"Fallback chain: {' → '.join(MODEL_CHAIN)}")
    print()
    
    # Verify proxy is running
    if not check_proxy_health():
        print("[ERROR] Antigravity proxy not running!")
        print("Start it with: antigravity-claude-proxy start")
        return
    
    print("[OK] Proxy health check passed")
    
    # Get items to review
    items = get_processed_items()
    if not items:
        print("[INFO] No items to review")
        return
    
    print(f"[INFO] Reviewing {len(items)} kinks...")
    total_flags = 0
    
    for kink in items:
        flags = review_kink(kink)
        total_flags += flags
        time.sleep(0.5)
    
    print(f"\n[DONE] Created {total_flags} flags from {len(items)} kinks reviewed")


if __name__ == "__main__":
    main()
